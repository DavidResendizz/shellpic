#!/usr/bin/env python
# -*- coding: utf-8; mode: Python -*-
#
#
# Lars JÃ¸rgen Solberg <supersolberg@gmail.com> 2014
#
import argparse
from PIL import Image
import sys
import cStringIO
import time

import shellpic

if __name__ == "__main__":
    
    # parse command line parameters
    parser = argparse.ArgumentParser()
    parser.add_argument("image", help="Use '-' to read from STDIN")
    parser.add_argument("--shell8", action="store_true", 
                        help="Print text suitable for a shell capable of displaying 8bit colors (default)")
    parser.add_argument("--shell24", action="store_true", 
                        help="Print text suitable for a shell capable of displaying 24bit colors")
    parser.add_argument("--irc", action="store_true", 
                        help="Print text suitable for piping to an irc client")
    parser.add_argument("--no-scale", action="store_true",
                        help="Do not attempt to scale the image to fit the terminal")
    parser.add_argument("--scale-x", nargs=1, type=int,
                        help="Scale the image to this width")
    parser.add_argument("--scale-y", nargs=1, type=int,
                        help="Scale the image to this height")
    parser.add_argument("--animate", action="store_true", 
                        help="Animate the image once")
    parser.add_argument("--loop", action="store_true", 
                        help="Animate the image and loop indefinetly")
    args = parser.parse_args()    

    # create the right kind of 'Formatter'
    if args.irc:
        formatter = shellpic.Irc()
    elif args.shell24:
        formatter = shellpic.Shell24Bit()
    else:
        formatter = shellpic.Shell8bit()
    dimentions = formatter.dimentions()
    
    # load the image
    if args.image == '-':
        # we need to copy the entire image to a buffer as PIL likes to seek()
        buf = cStringIO.StringIO()
        buf.write(sys.stdin.read())
        buf.seek(0)
        img = Image.open(buf)
        img.load() # so we can safely close buf
        buf.close()
    else:
        img = Image.open(args.image)

    # extract the frames for animation and convert them to RGBA
    if args.animate:
        frames = [img.convert('RGBA')]
        while True:
            try:
                img.seek(img.tell() + 1)
                frames.append(img.convert('RGBA'))
            except EOFError:
                break
    else:
        frames = [img.convert('RGBA')]

    # scale it to fit the terminal
    if not args.no_scale:
        if args.scale_x:
            dimentions = [args.scale_x[0], dimentions[1]]
        if args.scale_y:
            dimentions = [dimentions[0], args.scale_y[0]]
        
        # it seems like each frame must be resized individually 
        for i in range(0, len(frames)):
            frames[i] = shellpic.scale(frames[i], *dimentions)


    # print the image as an animation
    if args.animate or args.loop:
        duration = float(img.info['duration']) / 1000
        print formatter.clear_screen().encode('utf-8')
        try: 
            while True:
                for frame in frames:
                    print formatter.move_cursor(0, 0).encode('utf-8')
                    print formatter.format(frame).encode('utf-8')
                    time.sleep(duration)
                if not args.loop:
                    break
        except KeyboardInterrupt:
            print formatter.clear_screen().encode('utf-8')
    else:
        # or print the resutl to STDOUT
        print formatter.format(frames[0]).encode('utf-8')
